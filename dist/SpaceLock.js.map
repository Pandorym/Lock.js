{"version":3,"sources":["SpaceLock.ts"],"names":[],"mappings":"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","file":"SpaceLock.js","sourcesContent":["import { Promise } from 'bluebird';\nimport { Task } from './Task';\n\nexport class SpaceLock {\n    public key: string;\n    private _: Promise<void>;\n\n    public spaceSize: number;\n    public timeout: number;\n\n    public waitTaskQueue: Array<Task>;\n    public insideTaskQueue: Array<Task>;\n\n    public get currentNumber(): number {\n        return this.insideTaskQueue.length;\n    };\n\n    public static defaultOptions: { spaceSize: number, timeout: number } = {\n        spaceSize : 1,\n        timeout : null,\n    };\n\n    public get isFull() {\n        return !(this.currentNumber < this.spaceSize);\n    }\n\n    public get isLocked() {\n        return this.isFull;\n    }\n\n    public get hasWaitTask() {\n        return this.waitTaskQueue.length > 0;\n    }\n\n    constructor(key: string, options?: any) {\n\n        let _options = Object.assign({}, SpaceLock.defaultOptions, options);\n\n        this.spaceSize = _options.spaceSize;\n        this.timeout = _options.timeout;\n\n        this.key = key;\n        this.waitTaskQueue = [];\n        this.insideTaskQueue = [];\n    }\n\n    public update() {\n        for (; !this.isFull && this.hasWaitTask;) {\n            let task = this.waitTaskQueue.shift();\n            task.checkIn();\n            this.insideTaskQueue.push(task);\n        }\n    }\n\n    public checkOut(task_key?: string) {\n        let taskIndex = this.insideTaskQueue.findIndex((x) => x.key === task_key);\n        this.insideTaskQueue.splice(taskIndex, 1);\n\n        this.update();\n    }\n\n    public checkIn(task: Task): Promise<void>\n    public checkIn(task_key?: string, func?: any): Promise<void>\n    public checkIn(x?: string | Task, y?: any): Promise<void> {\n        let _task;\n        if (typeof x === 'object') {\n            _task = x;\n        } else {\n            _task = new Task(x, y);\n        }\n\n        this.waitTaskQueue.push(_task);\n\n        this.update();\n\n        return _task.token;\n    }\n\n    public doOnce(func: any, timeout: number = this.timeout, task_key? :string): Promise<any> {\n        let result: any;\n        let task = new Task(task_key, func);\n\n        return this\n            .checkIn(task)\n            .then(async () => {\n                if (timeout === null) {\n                    result = await task.exec();\n                } else {\n                    result = await task.exec()\n                                       .timeout(timeout);\n                }\n            })\n            .then(() => this.checkOut(task_key))\n            .then(() => result)\n            .catch((err) => {\n                this.checkOut(task_key);\n                return Promise.reject(err);\n            });\n    }\n\n    public doOnce_untilOneDone(func: any, timeout: number = this.timeout): Promise<any> {\n        let result: any;\n        let task = new Task(undefined, func);\n\n        return this\n            .checkIn(task)\n            .then(async () => {\n                let retry: boolean;\n                do {\n                    retry = false;\n                    try {\n                        if (timeout === null) {\n                            result = await task.exec();\n                        } else {\n                            result = await task.exec()\n                                               .timeout(timeout);\n                        }\n                    }\n                    catch (e) {\n                        retry = true;\n                    }\n                } while (retry);\n            })\n            .then(() => this.checkOut())\n            .then(() => result)\n            .catch((err) => {\n                console.log(err);\n                this.checkOut();\n                return Promise.reject(err);\n            });\n    }\n}\n"]}