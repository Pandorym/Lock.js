{"version":3,"sources":["SpaceLock.ts"],"names":[],"mappings":";;AAAA,iCAA+B;AAC/B,iCAA8B;AAE9B,MAAa,SAAS;IAoClB,YAAY,GAAW,EAAE,OAAa;QAjC9B,YAAO,GAAG,IAAI,MAAM,CAAC,YAAY,EAAE,CAAA;QAmCvC,IAAI,QAAQ,GAAG,MAAM,CAAC,MAAM,CAAC,EAAE,EAAE,SAAS,CAAC,cAAc,EAAE,OAAO,CAAC,CAAC;QAEpE,IAAI,CAAC,SAAS,GAAG,QAAQ,CAAC,SAAS,CAAC;QACpC,IAAI,CAAC,OAAO,GAAG,QAAQ,CAAC,OAAO,CAAC;QAEhC,IAAI,CAAC,GAAG,GAAG,GAAG,CAAC;QACf,IAAI,CAAC,aAAa,GAAG,EAAE,CAAC;QACxB,IAAI,CAAC,eAAe,GAAG,EAAE,CAAC;IAC9B,CAAC;IAnCD,IAAW,aAAa;QACpB,OAAO,IAAI,CAAC,eAAe,CAAC,MAAM,CAAC;IACvC,CAAC;IAAA,CAAC;IAOF,IAAW,MAAM;QACb,OAAO,CAAC,CAAC,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC,SAAS,CAAC,CAAC;IAClD,CAAC;IAED,IAAW,QAAQ;QACf,OAAO,IAAI,CAAC,MAAM,CAAC;IACvB,CAAC;IAED,IAAW,WAAW;QAClB,OAAO,IAAI,CAAC,aAAa,CAAC,MAAM,GAAG,CAAC,CAAC;IACzC,CAAC;IAED,IAAW,YAAY;QACrB,OAAO,CAAC,GAAG,IAAI,CAAC,eAAe,CAAC,MAAM,GAAG,IAAI,CAAC,aAAa,CAAC,MAAM,CAAA;IACpE,CAAC;IAcM,MAAM;QACT,OAAO,CAAC,IAAI,CAAC,MAAM,IAAI,IAAI,CAAC,WAAW,GAAG;YACtC,IAAI,IAAI,GAAG,IAAI,CAAC,aAAa,CAAC,KAAK,EAAE,CAAC;YACtC,IAAI,CAAC,OAAO,EAAE,CAAC;YACf,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;SACnC;IACL,CAAC;IAEM,QAAQ,CAAC,QAAiB;QAC7B,IAAI,SAAS,GAAG,IAAI,CAAC,eAAe,CAAC,SAAS,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,GAAG,KAAK,QAAQ,CAAC,CAAC;QAC1E,IAAI,IAAI,GAAG,IAAI,CAAC,eAAe,CAAC,SAAS,CAAC,CAAA;QAC1C,IAAI,CAAC,eAAe,CAAC,MAAM,CAAC,SAAS,EAAE,CAAC,CAAC,CAAC;QAE1C,IAAI,CAAC,MAAM,EAAE,CAAC;QAEd,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,UAAU,EAAE,IAAI,CAAC,CAAA;IACvC,CAAC;IAIM,OAAO,CAAC,CAAiB,EAAE,CAAO;QACrC,IAAI,KAAK,CAAC;QACV,IAAI,OAAO,CAAC,KAAK,QAAQ,EAAE;YACvB,KAAK,GAAG,CAAC,CAAC;SACb;aAAM;YACH,KAAK,GAAG,IAAI,WAAI,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;SAC1B;QAED,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QAE/B,IAAI,CAAC,MAAM,EAAE,CAAC;QAEd,OAAO,KAAK,CAAC,KAAK,CAAC;IACvB,CAAC;IAEM,MAAM,CAAC,IAAS,EAAE,UAAkB,IAAI,CAAC,OAAO,EAAE,QAAiB;QACtE,IAAI,MAAW,CAAC;QAChB,IAAI,IAAI,GAAG,IAAI,WAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC;QAEpC,OAAO,IAAI;aACN,OAAO,CAAC,IAAI,CAAC;aACb,IAAI,CAAC,KAAK,IAAI,EAAE;YACb,IAAI,OAAO,KAAK,IAAI,EAAE;gBAClB,MAAM,GAAG,MAAM,IAAI,CAAC,IAAI,EAAE,CAAC;aAC9B;iBAAM;gBACH,MAAM,GAAG,MAAM,OAAO,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,IAAI,EAAE,EAAE,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE,CAAC,UAAU,CAAC,GAAG,EAAE,CAAC,MAAM,CAAC,SAAS,CAAC,EAAE,OAAO,CAAC,CAAC,CAAC,CAAC,CAAA;aAC7H;QACL,CAAC,CAAC;aACD,IAAI,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC;aACnC,IAAI,CAAC,GAAG,EAAE,CAAC,MAAM,CAAC;aAClB,KAAK,CAAC,CAAC,GAAG,EAAE,EAAE;YACX,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC;YACxB,OAAO,OAAO,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;QAC/B,CAAC,CAAC,CAAC;IACX,CAAC;IAEM,mBAAmB,CAAC,IAAS,EAAE,UAAkB,IAAI,CAAC,OAAO,EAAE,gBAAwB,IAAI;QAC9F,IAAI,MAAW,CAAC;QAChB,IAAI,IAAI,GAAG,IAAI,WAAI,CAAC,SAAS,EAAE,IAAI,CAAC,CAAC;QAErC,OAAO,IAAI;aACN,OAAO,CAAC,IAAI,CAAC;aACb,IAAI,CAAC,KAAK,IAAI,EAAE;YACb,IAAI,KAAc,CAAC;YACnB,IAAI,QAAQ,GAAG,CAAC,CAAC;YACjB,GAAG;gBACC,QAAQ,EAAE,CAAC;gBACX,KAAK,GAAG,KAAK,CAAC;gBACd,IAAI;oBACA,IAAI,OAAO,KAAK,IAAI,EAAE;wBAClB,MAAM,GAAG,MAAM,IAAI,CAAC,IAAI,EAAE,CAAC;qBAC9B;yBAAM;wBACH,MAAM,GAAG,MAAM,OAAO,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,IAAI,EAAE,EAAE,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE,CAAC,UAAU,CAAC,GAAG,EAAE,CAAC,MAAM,CAAC,SAAS,CAAC,EAAE,OAAO,CAAC,CAAC,CAAC,CAAC,CAAA;qBAC7H;iBACJ;gBACD,OAAO,CAAC,EAAE;oBACN,IAAI,aAAa,KAAK,IAAI,IAAI,QAAQ,IAAI,aAAa,EAAE;wBACrD,OAAO,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;qBAC5B;oBACD,KAAK,GAAG,IAAI,CAAC;iBAChB;aACJ,QAAQ,KAAK,EAAE;QACpB,CAAC,CAAC;aACD,IAAI,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC;aAC3B,IAAI,CAAC,GAAG,EAAE,CAAC,MAAM,CAAC;aAClB,KAAK,CAAC,CAAC,GAAG,EAAE,EAAE;YACX,kDAAkD;YAClD,IAAI,CAAC,QAAQ,EAAE,CAAC;YAChB,OAAO,OAAO,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;QAC/B,CAAC,CAAC,CAAC;IACX,CAAC;IAEM,eAAe,CAAC,IAAS;QAC9B,OAAO,IAAI,OAAO,CAAC,QAAQ,CAAE,EAAE;YAC7B,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,UAAU,EAAE,QAAQ,CAAC,CAAA;YACvC,IAAI,CAAC,IAAI,CAAC,YAAY,EAAE;gBACtB,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,IAAI,EAAE,CAAA;aACzB;QACH,CAAC,CAAC,CAAA;IACJ,CAAC;;AApIa,wBAAc,GAA2C;IACnE,SAAS,EAAG,CAAC;IACb,OAAO,EAAG,IAAI;CACjB,CAAC;AAlBN,8BAoJC","file":"SpaceLock.js","sourcesContent":["import *as events from 'events'\nimport { Task } from './Task';\n\nexport class SpaceLock {\n    public key: string;\n    private _: Promise<void>;\n    private emitter = new events.EventEmitter()\n\n    public spaceSize: number;\n    public timeout: number;\n\n    public waitTaskQueue: Array<Task>;\n    public insideTaskQueue: Array<Task>;\n\n    public get currentNumber(): number {\n        return this.insideTaskQueue.length;\n    };\n\n    public static defaultOptions: { spaceSize: number, timeout: number } = {\n        spaceSize : 1,\n        timeout : null,\n    };\n\n    public get isFull() {\n        return !(this.currentNumber < this.spaceSize);\n    }\n\n    public get isLocked() {\n        return this.isFull;\n    }\n\n    public get hasWaitTask() {\n        return this.waitTaskQueue.length > 0;\n    }\n\n    public get hasExistTask() {\n      return 0 < this.insideTaskQueue.length + this.waitTaskQueue.length\n    }\n\n    constructor(key: string, options?: any) {\n\n        let _options = Object.assign({}, SpaceLock.defaultOptions, options);\n\n        this.spaceSize = _options.spaceSize;\n        this.timeout = _options.timeout;\n\n        this.key = key;\n        this.waitTaskQueue = [];\n        this.insideTaskQueue = [];\n    }\n\n    public update() {\n        for (; !this.isFull && this.hasWaitTask;) {\n            let task = this.waitTaskQueue.shift();\n            task.checkIn();\n            this.insideTaskQueue.push(task);\n        }\n    }\n\n    public checkOut(task_key?: string) {\n        let taskIndex = this.insideTaskQueue.findIndex((x) => x.key === task_key);\n        let task = this.insideTaskQueue[taskIndex]\n        this.insideTaskQueue.splice(taskIndex, 1);\n\n        this.update();\n\n        this.emitter.emit('checkout', task)\n    }\n\n    public checkIn(task: Task): Promise<void>\n    public checkIn(task_key?: string, func?: any): Promise<void>\n    public checkIn(x?: string | Task, y?: any): Promise<void> {\n        let _task;\n        if (typeof x === 'object') {\n            _task = x;\n        } else {\n            _task = new Task(x, y);\n        }\n\n        this.waitTaskQueue.push(_task);\n\n        this.update();\n\n        return _task.token;\n    }\n\n    public doOnce(func: any, timeout: number = this.timeout, task_key? :string): Promise<any> {\n        let result: any;\n        let task = new Task(task_key, func);\n\n        return this\n            .checkIn(task)\n            .then(async () => {\n                if (timeout === null) {\n                    result = await task.exec();\n                } else {\n                    result = await Promise.race([task.exec(), new Promise((resolve, reject) => setTimeout(() => reject('Timeout'), timeout))])\n                }\n            })\n            .then(() => this.checkOut(task_key))\n            .then(() => result)\n            .catch((err) => {\n                this.checkOut(task_key);\n                return Promise.reject(err);\n            });\n    }\n\n    public doOnce_untilOneDone(func: any, timeout: number = this.timeout, tryTimesLimit: number = null): Promise<any> {\n        let result: any;\n        let task = new Task(undefined, func);\n\n        return this\n            .checkIn(task)\n            .then(async () => {\n                let retry: boolean;\n                let try_time = 0;\n                do {\n                    try_time++;\n                    retry = false;\n                    try {\n                        if (timeout === null) {\n                            result = await task.exec();\n                        } else {\n                            result = await Promise.race([task.exec(), new Promise((resolve, reject) => setTimeout(() => reject('Timeout'), timeout))])\n                        }\n                    }\n                    catch (e) {\n                        if (tryTimesLimit !== null && try_time >= tryTimesLimit) {\n                            return Promise.reject(e);\n                        }\n                        retry = true;\n                    }\n                } while (retry);\n            })\n            .then(() => this.checkOut())\n            .then(() => result)\n            .catch((err) => {\n                // console.log('doOnce_untilOneDone error:', err);\n                this.checkOut();\n                return Promise.reject(err);\n            });\n    }\n\n    public needOneCheckout(func: any) : Promise<Task>{\n      return new Promise(resolved  => {\n        this.emitter.once('checkout', resolved)\n        if (!this.hasExistTask) {\n          this.doOnce(func).then()\n        }\n      })\n    }\n}\n"]}